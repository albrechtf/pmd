/*
**	The TODO list:
**		12.	It should handle a ":" appearing at the end of an inline If:
**				If x Then MsgBox "Hello":
**			(a trailing colon is handled in other cases).
**
**
**	The following have been fixed in version 3
**		1.	"Circle", "Line", "Pset" methods have special syntax. Best approach is
**			probably to skip to the end of line. It may also be best to handle
**			other peculiarities (such as .Print) in the same way.
**		2.	Open strRegFilename For Input Access Read Lock Read Write As #iFile will
**			fail because the token manager will read the "#if" as a conditional compilation.
**			Make it active only at start of line??
**			Also, we currently parse both the "Then" and "Else" halves of conditionally
**			compiled code. Should we only parse one half (but which to choose?)
**		3.	Print "Hello" does not work?
**		4.	"With New X" does not work.
**		5.  "Dim X!" is legal, the "!" indicating a float. It is distinguished from
**			"x = rs!columnName" by devious TokenManager processing
**		6.	Handles "Select Case" statements more gracefully, and generates sensible
**			AST nodes.
**		7.  Handle "Option Private Module"
**		8.	Handle "x = rs![Column Name With Spaces]".
**		9.	Handle "x = Input(1, #1)" and others.
**		10.	Handle "Set Property = x".
**		11. Allow "enum" etc. as a name within "Type" declarations.
**		13.	Do not add extra ":" to labels or extra "\n" to comments.
*/


options {
  MULTI = true;
  VISITOR = true;
  NODE_DEFAULT_VOID = true;
  NODE_SCOPE_HOOK = true;
  NODE_PACKAGE="com.github.albrechtf.pmd.lang.vb.ast";
  NODE_CLASS="com.github.albrechtf.pmd.lang.vb.ast.VBNode";
  NODE_USES_PARSER=true;
  
  IGNORE_CASE = true;
  JAVA_UNICODE_ESCAPE = false;
  UNICODE_INPUT = false;
  COMMON_TOKEN_ACTION = true;
  STATIC = false;
//  DEBUG_PARSER = true;
//  DEBUG_LOOKAHEAD = true;
//  DEBUG_TOKEN_MANAGER = true;
//  FORCE_LA_CHECK = true;
}

PARSER_BEGIN(VisualBasicParser)
package com.github.albrechtf.pmd.lang.vb.ast;

import java.io.*;

public class VisualBasicParser {

  private void jjtreeOpenNodeScope(Node n)
  {
	  ((VBNode)n).setFirstToken(getToken(1));
  }


  private void jjtreeCloseNodeScope(Node n)
  {
	  // Check that we have consumed at least one token.
	  VBNode sn = (VBNode)n;
	  if (sn.getFirstToken() == getToken(1))
	  {
		  // Not consumed any tokens. Set the first token to null
		  // to indicate that the list is empty. Set the last
		  // token to the "next" token, so that if we create children
		  // within this node, we know where to link in the corresponding
		  // tokens.
		  sn.setFirstToken(null);
		  sn.setLastToken(getToken(1));
	  }
	  else
	  {
		  sn.setLastToken(getToken(0));
	  }
  }


  /**
  **	Used to distinguish "a.b" (object a's method called b) and "a .b" (".b" is a parameter to method a).
  */
  private boolean hasLeadingSpace()
  {
  	//if (trace_enabled) System.out.println("hasLeadingSpace " + (getToken(1).specialToken != null));
  	return (getToken(1).specialToken != null);
  }

  static
  private boolean isSpecialMethod(String name)
  {
	  name = name.toLowerCase();

	  //System.out.println("IsSpecialMethod " + name);

	  return name.equals("print") ||
	  		 name.equals("line") ||		// NB: Covers "Line" and "Line Input"
	  		 name.equals("circle") ||
	  		 name.equals("pset") ||
	  		 name.equals("point") ||
	  		 name.equals("write") ||
	  		 name.equals("read") ||
	  		 name.equals("scale") ||
//	  		 name.equals("input") ||
	  		 name.equals("seek");
  }

  private boolean isIdentifier(String identifier)
  {
	  Token t = getToken(1);
	  return t.kind == IDENTIFIER && t.image.equalsIgnoreCase(identifier);
  }

  private void getAnyToken() throws ParseException
  {
//	  System.out.println("getAnyToken: <" + getToken(0).image + "> <" + getToken(1).image + ">");
	  getNextToken();
//	  System.out.println("           : <" + getToken(0).image + "> <" + getToken(1).image + ">");
  }

	private void skipToEndSection()
	{
		while (true)
		{
			Token tok = getToken(1);

			if (tok.kind == EOF)
				break;

			if (tok.kind == END && tok.specialToken == null)
			{
				// Found a line starting with word END. Skip
				// this line as well, and we should be in business.

				  while (getToken(1).kind != EOL)
				  {
					  getNextToken();
				  }

				break;
			}

			getNextToken();
		}
	}


	private boolean attemptErrorRecovery = false;
	public boolean getAttemptErrorRecovery()
	{
		return attemptErrorRecovery;
	}
	public void setAttemptErrorRecovery(boolean val)
	{
		attemptErrorRecovery = val;
	}

	private void handleParseError(ParseException e) throws ParseException
	{
	   System.out.println("========================================================================================");
	   System.out.println("Error at line " + getToken(1).beginLine + ": " + getToken(1).image );
	   System.out.println("Statement not recognised");
	   //System.out.println(e);
	   e.printStackTrace();
	   //try
	   //{
		//   throw(new Exception("Now at line"));
	   //}
	   //catch(Exception whereAmI)
	   //{
		//   whereAmI.printStackTrace();
	   //}
	   error_skiptobefore(EOL);
	   System.out.println("Next tokens <" + getToken(1).image + "> <" + getToken(2).image + ">" );
	}

}

PARSER_END(VisualBasicParser)

TOKEN_MGR_DECLS :
{
	/**
	**	VB can have line numbers, e.g.
	**		10 Dim X as Integer
	**		20 X = 10
	*/
	static String currentLineNumberLabel = "";

	/*
	**	Add any VB line number to each token on that line.
	*/
	static void CommonTokenAction(Token t)
	{
		t.currentLineNumberLabel = currentLineNumberLabel;
	}

}

SPECIAL_TOKEN : /* WHITE SPACE */
{
	<SPACE: ( " " | "\t" | "\r" | "\f" | " _\r\n" )+ >
}


TOKEN :
{
   < EOL: "\n" >
			{
				currentLineNumberLabel = null;
			}
 		: START_OF_LINE
}


/*
**	Strip out any labels in the Lexer. This avoids major complications in
**	the parser. For example we would need to cater for statements labels
**	*within* compound statements:
**		For i = 1 To 5
**			Debug.Print i
**		Lbl1: Next i
**	This complicates the grammar and has quite an effect on the lookahead
**	required. Instead we treat labels as a type of statement.
*/
<START_OF_LINE> SPECIAL_TOKEN :
{
   <LEADING_SPACE: ( " " | "\t" | "\r" | "\f" | " _\r\n" )+ >
 | <LINE_NUMBER: (["0"-"9"])+ >
 		{ currentLineNumberLabel = image.toString(); }
 | <BLANK_LINE: "\n">
}

<START_OF_LINE> TOKEN :
{
   <STATEMENT_LABEL: ["A"-"Z"] (["A"-"Z"] | "_" | ["0"-"9"])+ ":">
   		{
			// Exclude the ":" from the label token.
			input_stream.backup(1);
			matchedToken.image = matchedToken.image.substring(0, matchedToken.image.length()-1);
		}
   	: DEFAULT
}

 /* Compiler Directives */

<START_OF_LINE> MORE :
{
  < COMP_CONST: "#Const" > : DIRECTIVE_IGNORE
| < COND_IF: "#If" > : DIRECTIVE_IGNORE			// We parse the "Then" part of the conditional code, not the else / ElseIf
| < COND_END_IF: "#End If" >
}


<START_OF_LINE> MORE :
{
  < COND_ELSE: "#Else" > : DIRECTIVE_SKIP		// Ignore the following code
| < COND_ELSEIF: "#ElseIf" > : DIRECTIVE_SKIP
}

<START_OF_LINE> MORE :
{
   < "" > : DEFAULT
}

<DIRECTIVE_IGNORE> SPECIAL_TOKEN :
{
  < "\n" > : START_OF_LINE
}

<DIRECTIVE_IGNORE> MORE :
{
  < ~[] >
}

<DIRECTIVE_SKIP> MORE :
{
  < "#End If" > : DIRECTIVE_IGNORE
| < ~[] >
}




MORE : /* COMMENTS */
{
  "'" : WITHIN_COMMENT
}

<WITHIN_COMMENT> MORE :
{
	// The VB line continuation character ("_") can be used to continue comments
	// over more than one line, as in
	//		'  This is a _
	//		   multi-line comment.
	// The following checks for this.

	< (~["\n"])* " _" ("\r")? "\n" >
}

<WITHIN_COMMENT> SPECIAL_TOKEN :
{
	< "\n" >
		{
			// Exclude "\n"
			input_stream.backup(1);
			matchedToken.image = matchedToken.image.substring(0, matchedToken.image.length()-1);
		}
		: DEFAULT
}

<WITHIN_COMMENT> MORE :
{
	< ~[] >
}

MORE :	// The REM "statement" -- really just a comment
{
	<REM_COMMENT: <REM> <SPACE> > : WITHIN_COMMENT
			// Strictly speaking, does not cater for "REM\n", but we know VB
			// will use \r\n for line terminators. And who uses REMs nowadays...
}

/* Strings */

MORE :
{
  "\"" : WITHIN_STRING
}

<WITHIN_STRING> MORE :
{
  <"\"\""> : WITHIN_STRING
}


<WITHIN_STRING> TOKEN :
{
  < UNTERMINATED_STRING_LITERAL:  "\n" > : DEFAULT
}

<WITHIN_STRING> TOKEN :
{
  < STRING_LITERAL: "\"" > : DEFAULT
}

<WITHIN_STRING> MORE :
{
  < ( ~[] ) >
}



TOKEN : /* RESERVED WORDS AND LITERALS */
{

  < ACCESS: "Access" >
| < ADDRESSOF: "AddressOf" >
| < APPEND: "Append" >
| < AND: "And" >
| < AS: "As" >
| < ATTRIBUTE: "Attribute" >
| < BEGIN: "Begin" >
| < BINARY: "Binary" >
| < BYREF: "ByRef" >
| < BYVAL: "ByVal" >
| < CALL: "Call" >
| < CASE: "Case" >
| < CLASS: "Class" >
//| < CLOSE: "Close" >
| < CONST: "Const" >
| < DEBUG_PRINT: "Debug.Print" >
| < DEBUG_ASSERT: "Debug.Assert" >
| < DECLARE: "Declare" >
| < DEFMODE: ( "DefBool" | "DefByte" | "DefInt" | "DefLng" | "DefCur" | "DefSng" | "DefDbl" | "DefDec" | "DefDate" | "DefStr" | "DefObj" | "DefVar" ) >
| < DIM: "Dim" >
| < DO: "Do" >
| < EACH: "Each" >
| < ELSE: "else" >
| < ELSEIF: "ElseIf" >
| < END: "End" >
| < ENUM: "Enum" >
| < EQV: "Eqv" >
| < ERROR: "Error" >
| < EVENT: "Event">
| < EXIT: "Exit" >
| < FALSE: "false" >
| < FOR: "for" >
| < FRIEND: "Friend" >
| < FUNCTION: "Function" >
| < GET: "Get" >
| < GLOBAL: "Global" >
| < GOTO: "Goto" >
| < IF: "If" >
| < IMP: "Imp" >
| < IMPLEMENTS: "implements" >
| < IN: "In" >
| < IS: "Is" >
| < LIB: "Lib" >
| < LIKE: "Like" >
| < LET: "Let" >
| < LOCK: "Lock" >
| < LOOP: "Loop" >
| < ME: "Me" >
| < MOD: "Mod" >
| < NAME: "Name" >
| < NEW: "New" >
| < NEXT: "Next" >
| < NOT: "Not" >
| < ON: "On" >
| < OPEN: "Open" >
| < OPTION: "Option" >
| < OPTIONAL: "Optional" >
| < OR: "Or" >
| < OUTPUT: "Output" >
| < PARAMARRAY: "ParamArray" >
| < PRESERVE: "Preserve" >
| < PRIVATE: "private" >
| < PROPERTY: "Property" >
| < PROTECTED: "Protected" >
| < PUBLIC: "Public" >
| < PUT: "Put" >
| < RANDOM: "Random" >
| < READ: "Read" >
| < REM: "Rem" >
| < REDIM: "ReDim" >
| < RESUME: "Resume" >
| < SELECT: "Select" >
| < SET: "Set" >
| < SHARED: "Shared" >
| < SHORT: "short" >
// | < SPC: "Spc" > done semantically
| < STATIC: "static" >
| < STEP: "Step" >
| < SUB: "Sub" >
| < SWITCH: "switch" >
// | < TAB: "Tab" > done semantically
| < THEN: "Then" >
| < TO: "To" >
| < TRUE: "true" >
| < TYPE: "Type" >
| < TYPEOF: "TypeOf" >
| < UNTIL: "Until" >
| < VERSION: "Version" >
| < WEND: "Wend" >
| < WHILE: "while" >
| < WITH: "With" >
| < WITHEVENTS: "WithEvents" >
| < WRITE: "Write" >
| < XOR: "Xor" >
}


TOKEN : /* LITERALS */
{
  < INTEGER_LITERAL:
        <DECIMAL_LITERAL>
      | <HEX_LITERAL>
      | <OCTAL_LITERAL>
  >
|
  < LONG_LITERAL:
  		<DECIMAL_LITERAL> "&"
  	  | <HEX_LITERAL> "&" >
|
  < #DECIMAL_LITERAL: (["0"-"9"])+ >
|
  < #HEX_LITERAL: "&" "H" (["0"-"9","a"-"f"])+ >
|
  < #OCTAL_LITERAL: "&" ["o"] (["0"-"7"])+ >
|
  < FLOATING_POINT_LITERAL:
      (( <DECIMAL_LITERAL> | <FRACTION> ) (<EXPONENT>)?) ( "#" | "!" | "@")?
  >
|
  < #FRACTION: (<DECIMAL_LITERAL>) "." (["0"-"9"])* | "." (["0"-"9"])+ >
|
  < #EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ >
|
  < DATE_LITERAL: "#" ( <DATE_ONLY_LITERAL> ( " " <TIME_ONLY_LITERAL> )? | <TIME_ONLY_LITERAL>  ) "#" >
|
  < #DATE_ONLY_LITERAL: <DECIMAL_LITERAL> "/" <DECIMAL_LITERAL> "/" <DECIMAL_LITERAL> >
|
  < #TIME_ONLY_LITERAL: <DECIMAL_LITERAL> ":" <DECIMAL_LITERAL> ":" <DECIMAL_LITERAL> ( " " )+ ( "AM" | "PM" ) >
}




/*
// Problem with this approach is that "Integer" would match as "In"


MORE :
{
  < [ "A"-"Z", "_" ] > : IN_IDENT
}

<IN_IDENT> MORE :
{
  < [ "A"-"Z", "_" ] >
| < [ "0"-"9" ] >
| < [ "%" , "#", "$", "&" ] > : END_IDENT
| < "!" ~["A"-"Z", "["] > { input_stream.backup(1); } : END_IDENT
| < ~[] > { input_stream.backup(1); } : END_IDENT
}

<END_IDENT> TOKEN :
{
  < IDENTIFIER: ~[] > { input_stream.backup(1); } : DEFAULT
}

//MORE :
//{
//  < "[" <LETTER> (<LETTER>|<DIGIT>)* "]" > : END_IDENT
//}
*/

 /*
 ** IDENTIFIERS.
 ** Identifiers in VB are complex beasts. As well as the "normal" formats
 ** found in Java, C etc., an identifier may be:
 **	1.	A normal identifier enclosed in square brackets, e.g.
 **			[Next]
 **		This allows VB to access externally-defined names that might break
 **		VB's own naming rules (typically used for reserved words etc)
 **	2.	A normal identifier suffixed by a "type-declaration character". These
 **		characters declare the variables type, such as Integer or Long. E.g.
 **			Dim x$
 **		is equivalent to
 **			dim x As String
 **		There is one large complication here. The "!" character is used to
 **		define floats. This conflicts with the use of "!" as a binary operator,
 **		such as
 **			thing = rs!colName
 **		This has been resolved by peeking at the character following the "!". If
 **		it is not a letter or a "[" it is assumed to be a binary operator. In this
 **		case the character is removed from the token and put back on the input stream.
 */
TOKEN :
{
  < IDENTIFIER: ( <PLAIN_IDENTIFIER> | <DELIMITED_IDENTIFIER> ) >
		{
			char ch = matchedToken.image.charAt(matchedToken.image.length() -1);
			if (ch == '!')
			{
				try
				{
					// Peek at the next character.
					char nextCh = input_stream.readChar();
					input_stream.backup(1);

					if (nextCh == '[' || nextCh == '_' || Character.isLetter(nextCh))
					{
						// The "!" was NOT part of the identifier. Rather it was a binary
						// operator such as x = rs!colName.
						// Put the "!" back on the input stream
						input_stream.backup(1);
						// And remove it from the token
						matchedToken.image = matchedToken.image.substring(0, matchedToken.image.length()-1);
					}
				}
				catch (IOException e)
				{
					throw new Error(e.toString());
				}
			}
			//System.out.println("IDENT: " + matchedToken.image);
		}

|
  < #PLAIN_IDENTIFIER: <LETTER> (<LETTER>|<DIGIT>)*  ( <IDENT_SUFFIX> )? >
|
  < #DELIMITED_IDENTIFIER: "[" <PLAIN_IDENTIFIER> "]" >
|
  < #LETTER: [ "A"-"Z", "_" ] >
|
  < #DIGIT:  [ "0"-"9" ] >
|
  < #IDENT_SUFFIX: [ "%" , "#", "$", "&" , "!" ] >
  //< #IDENT_SUFFIX: [ "%" , "#", "$", "&", "!" ] <SPACE> >
}

TOKEN : /* SEPARATORS */
{
  < LPAREN: "(" >
| < RPAREN: ")" >
| < LBRACE: "{" >
| < RBRACE: "}" >
| < LBRACKET: "[" >
| < RBRACKET: "]" >
| < SEMICOLON: ";" >
| < COMMA: "," >
| < HASH: "#" >
| < DOT: "." >
}

TOKEN : /* OPERATORS */
{
  < ASSIGN: "=" >
| < GT: ">" >
| < LT: "<" >
| < BANG: "!" >
| < TILDE: "~" >
| < HOOK: "?" >
| < COLON: ":" >
| < LE: "<=" >
| < GE: ">=" >
| < NE: "<>" >
| < PLUS: "+" >
| < MINUS: "-" >
| < STAR: "*" >
| < SLASH: "/" >
| < BIT_AND: "&" >
| < PERCENT: "%" >
| < BACKSLASH : "\\" >
| < EXPO: "^" >
}

// Prevent lexer-generated errors if unexpected character.
TOKEN :
{
	< ANYTHING_ELSE: ( ~[] ) >
}

/*****************************************
 * THE VB LANGUAGE GRAMMAR STARTS HERE *
 *****************************************/

/*
 * Program structuring syntax follows.
 */

ASTCompilationUnit CompilationUnit() #CompilationUnit :
{}
{
  [ DiscardProlog() ]
  ( LOOKAHEAD(4) ModuleLevelStatements() )*
  ( ProcDeclaration() (<EOL>)+ )*
  <EOF>
		{
		  return jjtThis;
		}
}

/**
**	VB files start with a prolog (invisible to a user in the IDE). We are
**	not (yet) interested in this prolog, so skip it.
*/

void DiscardProlog() :
{}
{
    <VERSION> { skipToEndSection(); }
}

// ==============================================================================================================================
/**
**	The following are all statements that can appear at the module level,
**	i.e outside of subs etc.
**	YOU MAY WANT TO SKIP OVER THESE.
*/

void ModuleLevelStatements() :
{}
{
    OptionStatement() Eos()
//  | CompilerDirective() Eos()
  | ImplementsDecl() Eos()
  | DefModeStatement()
  | LOOKAHEAD(2) TypeDeclaration() Eos()
  | LOOKAHEAD(2) EventDeclaration() Eos()
  | LOOKAHEAD(2) ConstDeclaration() Eos()
  | LOOKAHEAD(2) EnumDeclaration() Eos()
  | LOOKAHEAD(2) DeclareStatement() Eos()
  | ModLevelDeclaration() Eos()
  | <ATTRIBUTE> PrimaryExpression() "=" Expression() ( "," Expression() )* Eos()
  | Eol()
}

//void CompilerDirective() :
//{}
//{
//	( <COMP_CONST> | <COND_IF> | <COND_ELSE> | <COND_ELSEIF> | <COND_END_IF> ) skipToEoln()
//}

void OptionStatement() #Option :
{}
{
    <OPTION> ( AnyName() | Literal() | <PRIVATE> )+
}

void ModLevelDeclaration() #Declaration :
{}
{
    ModScopeDecl() VariableDeclaration() ( "," VariableDeclaration() )*
}

void EventDeclaration() #EventDeclaration :
{}
{
	[ ModScopeDecl() ] <EVENT> Name() [ "(" FormalParamList() ")" ]
}

void TypeDeclaration() #TypeDeclaration :
{}
{
	[ ModScopeDecl() ] <TYPE> Name() Eos()
		( LOOKAHEAD(2) [ AnyVariableDeclaration() ] Eos())+
	<END> <TYPE>
}

void EnumDeclaration() #EnumDeclaration :
{}
{
	[ ModScopeDecl() ] <ENUM> Name() Eos()
		( [ Name() [ "=" Expression() ] ] Eos())+
	<END> <ENUM>
}

void DefModeStatement() #Statement :
{}
{
	<DEFMODE> <IDENTIFIER> "-" <IDENTIFIER> ( "," <IDENTIFIER> "-" <IDENTIFIER> )*
}

void ImplementsDecl() #Implements :
{}
{
	<IMPLEMENTS> TypeName()
}

void ModScopeDecl() :
{}
{
    ( <PUBLIC> | <PRIVATE> | <FRIEND> | <DIM> | <GLOBAL> ) [ <STATIC> ]
}


// ==============================================================================================================================
/**
**	The following are top-level productions for Subs, Functions and Properties
*/

void ProcDeclaration() #ProcDeclaration :
{}
{
	(
	    LOOKAHEAD(3) SubDeclaration()		{ jjtThis.setProcType(SUB); }
	  | LOOKAHEAD(3) FunctionDeclaration()	{ jjtThis.setProcType(FUNCTION); }
	  | LOOKAHEAD(4) PropertyDeclaration()	{ jjtThis.setProcType(PROPERTY); }
//	  | CompilerDirective()
	)
}

void SubDeclaration() :
{}
{
    [ <STATIC> ] [ ModScopeDecl() ] <SUB> Name() [ "(" FormalParamList() ")" ] Eos()
    Statements()
    <END> <SUB>
}

void FunctionDeclaration() :
{}
{
	[ <STATIC> ] [ ModScopeDecl() ] <FUNCTION> Name() [ "(" FormalParamList() ")" ] [ <AS> TypeName() [ "(" ")" ] ] Eos()
	Statements()
	<END> <FUNCTION>
}

void PropertyDeclaration() :
{}
{
    LOOKAHEAD(3) PropertyGetDeclaration()
  | LOOKAHEAD(3) PropertyLetDeclaration()
  | LOOKAHEAD(3) PropertySetDeclaration()
}

void PropertyGetDeclaration() :
{}
{
    [ <STATIC> ] [ ModScopeDecl() ] <PROPERTY> <GET> Name() [ "(" FormalParamList() ")" ] [ <AS> TypeName() [ "(" ")" ] ] Eos()
    Statements()
    <END> ( <PROPERTY> | <FUNCTION> )
}

void PropertyLetDeclaration() :
{}
{
    [ <STATIC> ] [ ModScopeDecl() ] <PROPERTY> <LET> Name() [ "(" FormalParamList() ")" ] Eos()
    Statements()
    <END> <PROPERTY>
}

void PropertySetDeclaration() :
{}
{
    [ <STATIC> ] [ ModScopeDecl() ] <PROPERTY> <SET> Name() [ "(" FormalParamList() ")" ] Eos()
    Statements()
    <END> <PROPERTY>
}

void FormalParamList() #FormalParamList :
{}
{
    [ ParamSpec() ( "," ParamSpec() )* ]
}

void ParamSpec() :
{}
{
	[ LOOKAHEAD(1) <OPTIONAL> ] ( <BYVAL> | <BYREF> )? [ <PARAMARRAY> ] AnyName() [ "(" ")" ]
		[ <AS> TypeName() [ "*" Expression() ] ] [ "=" Expression() ]
}


// ==============================================================================================================================
/**
**	The following are the productions for the procedure-level statements.
*/

void Statements() #Statements :
{}
{
    (
		/*
		** Important Note: If the lookahead below is increased to more than 3, then
		** the parser will probably fail. This is because the semantic lookahead in
		** the PrimarySuffix production is not evaluated during outer (nested) lookahead.
		** (This seems to be a bug/restriction).
		** Therefore lookahead assumes that statements such as
		**		MsgBox .X & "Str"
		** are parsed as
		**		MsgBox.X & "Str"
		** which generates a failure.
		** NB: The amount of LA that is tolerable seems to depend on the order of some
		**
		*/

		LOOKAHEAD(3)
			[
				Statement()
			] Eos()
    )*
}



/**
** Error handling in the Statement() production.
**	There is a big problem with the error handling in the Statement()
**	production. If we have a statement such as
**		If a > b And c < d And Then
**	then error recovery works (a ParseException is generated while
**	processing the "Expression()" syntax, and is correctly trapped
**	in the Statement() production).
**
**	However, an error such as the following is handled badly:
**		Do While A > B
**			CallSomething
**			If If X = Y The Exit Sub
**			CallSomethingElse
**		Loop
**	The 3rd line is invalid (the word "If" has been repeated). In this case
**	JavaCC recognises that "If If" is not a valid start to the Statement()
**	production, so the loop in the Statements() [plural!] production
**	terminates -- this generates a ParseException in the DoWhile() production.
**	This means that the ParseException is actually caught by the Statement()
**	production handling the "DoWhile" statement. Therefore the parser then
**	thinks it has exited the DoWhile statement so marks the "Loop" statement
**	as an error as well
**
**	Thoughts on a fix to this:
**	1)	Change the way Statements() [plural!] works. At the moment it
**		consumes statements until it finds something that does not look
**		like the start of a statement. This may be a valid "block terminator"
**		such as "End If" or "Loop", or it could be a syntax error.
**		Statements() would need to change so that it recognised the valid block
**		terminators, and treated the rest as syntax errors (and continued
**		reading statements).
**	2)	All of the block statements trapped errors and continued.
**
**	Both of these seem to be nasty bodges.
**
** SUMMARY
**	This parser makes a half-hearted attempt to recover from some syntax
**	errors. This recovery is far from perfect, so you should assume that
**	the parser will only operate correctly on syntactically correct files.
*/

void Statement() :
{
	ParseException pe = null;
}
{
	try
	{
	  (
//		CompilerDirective() #Statement
	    LabelStatement()
	//  | RemStatement()
	  | DebugStatement()
	  | LOOKAHEAD(IsEndStatement()) EndStatement()
	  | ( <ATTRIBUTE> PrimaryExpression() "=" Expression() ) #Statement
	  | LOOKAHEAD(2) ProcLevelDeclaration()
	  | LOOKAHEAD(2) DeclareStatement()
	  | LOOKAHEAD(2) ConstDeclaration()
	  | Let()
	  | Set()
	  | OnErrorStatement()
	  | GotoStatement()
	  | LOOKAHEAD(<IF>) IfStatement()
	  | DoWhile()
	  | WhileWend()
	  | CallStatement()
	  | ExitStatement()
	  | LOOKAHEAD(2) ForEachStatement()
	  | ForStatement()
	  | WithStatement()
	  | ResumeStatement()
	  | CaseStatement()
	  | LOOKAHEAD( <NAME> Expression() <AS> ) NameStatement()
	  | OpenStatement()
	  | LOOKAHEAD({isIdentifier("Close")}) CloseStatement()
//	  | PrintFileStatement()
	  | RedimStatement()
//	  | LOOKAHEAD(2) LineInputStatement()
	  | GetStatement()
	  | PutStatement()
	  | PrimaryExprStatement()
	  )
   }
   catch (ParseException e)
   {
	   if (!attemptErrorRecovery)
	   		throw(e);

	   pe = e;
	   handleParseError(e);
   }

   //[ LOOKAHEAD(0, { pe != null }) error_skiptobefore(EOL) #UnrecognisedStatement ]

		{
			if (pe == null)
			{
				try
				{
					ASTStatement s = (ASTStatement)(jjtree.peekNode());
					if (s.begin != null)
					{

						s.setLineNumber(s.begin.currentLineNumberLabel);
					}
				}
				catch (Exception e)
				{
					System.out.println("Set Line Number -- error at " + getToken(0).beginLine);
					System.out.println(e);
				}
			}
		}

}


// This production must be specified in this weird format so that
// we do not have to use LOOKAHEAD (which would mess up the semantic
// lookahead in "PrimaryExpression()"
// This seems to be a restriction in JavaCC.

void PrimaryExprStatement() :
{
	Token firstToken = getToken(1);
}
{
	PrimaryExpression()
	(	"=" Expression()	#Assignment(2)
	  | LOOKAHEAD({isSpecialMethod(getToken(0).image)})
	  		skipToEoln()	#MethodCall(1)
	  |	ArgList()			#MethodCall(2)
	)

	{
		VBNode sn = (VBNode)(jjtree.peekNode());
		sn.begin = firstToken;
		sn.end = getToken(0);
	}
}

void LabelStatement() #Label :
{}
{
	<STATEMENT_LABEL>
}


void DebugStatement() #Statement :
{}
{
	( <DEBUG_PRINT> | <DEBUG_ASSERT> ) skipToEoln()
}

void EndStatement() #Statement :
{}
{
	<END>
}

// For LOOKAHEAD only
void IsEndStatement() :
{}
{
	<END> <EOL>
}


void ProcLevelDeclaration() #Declaration :
{}
{
    ProcScopeDecl() AnyVariableDeclaration() ( "," AnyVariableDeclaration() )*
}

void ProcScopeDecl() :
{}
{
    ( < STATIC > | <DIM> )
}

void VariableDeclaration() #VarDecl :
{}
{
	[ <WITHEVENTS> ] Name() [ "(" [ VariableDimensions() ] ")" ]
		[ <AS> [LOOKAHEAD(1) <NEW> ] TypeName() ] [ "*" (Literal() | AnyName() ) ]
}

void AnyVariableDeclaration() #VarDecl :
{}
{
	AnyName() [ "(" [ VariableDimensions() ] ")" ]
		[ <AS> [LOOKAHEAD(1) <NEW> ] TypeName() ] [ "*" (Literal() | AnyName()) ]
}


void VariableDimensions() :
{}
{
	VariableDimension() ( "," VariableDimension() )*
}

void VariableDimension() #VarDim :
{}
{
	Expression() [ <TO> Expression() ]
}

void RedimStatement() #ReDim :
{}
{
	<REDIM> [ <PRESERVE> ] RedimClause() ( "," RedimClause() )*
}

void RedimClause() :
{}
{
	Name() "(" VariableDimensions() ")"
	[ <AS> [LOOKAHEAD(1) <NEW> ] TypeName() ] [ "*" Literal() ]
}


void DeclareStatement() #Declare :
{}
{
	[ ModScopeDecl() ] <DECLARE> ( <SUB> | <FUNCTION> ) Name() <LIB> Literal()
		[ LOOKAHEAD({isIdentifier("Alias")})  <IDENTIFIER> Literal() ]
		[ "(" FormalParamList() ")" ]
		[ <AS> Name() [ "(" ")" ] ]
}

void ConstDeclaration() #ConstDeclaration :
{}
{
	[ ModScopeDecl() ] <CONST> ConstSpec() ( "," ConstSpec() )*
}

void ConstSpec() :
{}
{
	Name() [ <AS> Name() [ "*" (Literal() | AnyName() ) ] ] "=" Expression()
}


void Set() #SetStatement :
{}
{
    <SET> PrimaryExpression() "=" Expression()
}

void Let() #Assignment :
{}
{
	<LET> PrimaryExpression() "=" Expression()
}

void OnErrorStatement() #OnError :
{
}
{
	<ON> [ <IDENTIFIER> ] <ERROR> ( <RESUME> [ <NEXT> ] | <GOTO> (Name() | Literal() ) )
}

void GotoStatement() #Statement :
{}
{
	<GOTO> (Name() | <INTEGER_LITERAL>)
}

void IfStatement() #IfStatement :
{}
{
	<IF> Expression() <THEN>
	(
		Eol() MultilineIf()
	  | [ ":" ] InlineIf()
	)
}

void InlineIf() :
{}
{
	Statement() ( LOOKAHEAD(1) ":" [Statement()] )* [ LOOKAHEAD(1) <ELSE> Statement() ( LOOKAHEAD(1) ":" [Statement()] )* ]
}

void MultilineIf() :
{}
{
		Statements()
	( <ELSEIF> Expression() <THEN> Eos()
		Statements()
	)*
	[ <ELSE> Eos()
		Statements() ]
	<END> <IF>
}

void DoWhile() #DoWhileStatement :
{}
{
	<DO> [ DoCondition() ] Eos()
		Statements()
	<LOOP> [ DoCondition() ]
}

void DoCondition() #DoCondition :
{}
{
	(    <WHILE> { jjtThis.conditionWhile = true; }
	   | <UNTIL> { jjtThis.conditionWhile = false; }
	) Condition()
}

void WhileWend() #WhileWendStatement :
{}
{
	<WHILE> Condition() Eos()
		Statements()
	<WEND>
}

void ForEachStatement() #ForEachStatement :
{}
{
	<FOR> <EACH> Name() <IN> Expression() Eos()
		Statements()
	<NEXT> [ Name() ]
}

void ForStatement() #ForStatement :
{}
{
	<FOR> Name() "=" Expression() <TO> Expression() [ <STEP> Expression() ] Eos()
		Statements()
	<NEXT> [ Name() ]

}

void WithStatement() # WithStatement :
{}
{
	<WITH> Expression()
	// Was "<WITH> PrimaryExpression()" -- PrimaryExpression seems more correct, but does not cater for "With New XX"
		Statements()
	<END> <WITH>
}

void ResumeStatement() #Statement :
{}
{
	<RESUME> [ <NEXT> | Name() ]
}


/*
** An oddity in the case statement. The documentation says that no statements are
** allowed between "Select Case" and the first "Case" clause. In fact, declarations
** ARE allowed before (any) "Case" clause.
*/

void CaseStatement() #CaseStatement :
{}
{
	<SELECT> <CASE> Expression() Eos()
	  (
		  LOOKAHEAD(2) CaseClause()
	  )*
	<END> <SELECT>
}

void CaseClause() :
{}
{
	( [ ProcLevelDeclaration() ] Eos() )*
	<CASE> CaseExprList()
	Statements()
}

void CaseExprList() :
{}
{
	CaseExpr() ( "," CaseExpr() ) *
}

void CaseExpr() #CaseExpr :
{}
{
	[ <IS> ] ( "<" | ">" | "<=" | ">=" | "=" | "<>" | <LIKE> ) Expression()
  |	Expression() [ <TO> Expression() ]
  | <ELSE>
}

void CallStatement() #MethodCall :
{}
{
	<CALL> PrimaryExpression() [ "(" ArgList() ")" ]
}


// TODO Comments. Also need tree to differ for func(x, , y),
// func(x, y) and func(, y, z)

void ArgList() #ArgList :
{}
{
//	( ( "," )* ArgSpec() )*
//	[ ArgSpec() ( "," [ ArgSpec() ] )* ]
	[ LOOKAHEAD(( "," )* ArgSpec()) ( "," )* ArgSpec() ] ( ( "," )+ ArgSpec() )*
}

void ArgSpec() #ArgSpec :
{}
{
	( <BYVAL> | <BYREF> )?
	( LOOKAHEAD(2) NamedArg() | UnNamedArg() )

}

void NamedArg() :
{}
{
	AnyName() ":=" Expression()
}

void UnNamedArg() :
{}
{
	Expression()
}


void ExitStatement() #ExitStatement :
{}
{
	<EXIT> ( <FUNCTION> | <PROPERTY> | <SUB> | <DO> | <FOR> | <WHILE> )
}

void TypeName() #TypeName :
{}
{
    AnyName() [ "." AnyName() ]
}

//void OtherStatement() :
//{}
//{
//    <NOTDONE> { skipToEoln(); }
//}

/**
**   Name() and AnyName()
**   ====================
**
** VB does not allow reserved words (such as "New") to be used
** as identifiers. E.g. these are not valid:
**
**		Dim New As Integer		// INVALID
**		Open = 66				// INVALID
**
** However it does permit the names of member variables/methods
** in expressions etc to be reserved words (presumably this is because
** an object may have been created in a language other than VB, and that
** language may have different keywords). Therefore these are valid:
**
**		X = Obj.Sub.If
**		Public Type YY
**			Sub As Integer
**		End
**
** NB: To confuse things even further, there are some keywords such as
** "Name" which can also be used as the names of variables, e.g.
**
**		Name "Thing.txt" As "Thing.bak"
**		Dim Name as String
**		Name = "X"
**
** The "Name()" production lists all names that can be used directly
** as variable, i.e. that can appear in a "Dim" statement, or can appear
** on the RHS
*/

void Name() #Name :
{}
{
	(
		<IDENTIFIER>
	  | <ACCESS>
	  | <APPEND>
	  | <BEGIN>
	  | <BINARY>
	  | <CLASS>
	  | <ERROR>
	  | <ME>
	  | <NAME>
	  | <OUTPUT>
	  | <PROPERTY>
	  | <RANDOM>
	  | <READ>
	  | <STEP>
	  | <SWITCH>
	  | <VERSION>
	  | <WRITE>
	)
  	{
		jjtThis.setName(getToken(0).image);
	}
}

void AnyName() #Name(jjtree.nodeArity() == 0):
{}
{
	(
		Name()
	  | <DEFMODE>
	  | <ENUM>
	  | <EVENT>
	  | <GET>
	  | <LET>
	  | <NEW>
	  | <OPEN>
	  | <OPTIONAL>
	  | <NEXT>
	  | <PUT>
	  | <SET>
	  | <TYPE>
	  | <TYPEOF>
	  | <END>
	  | <REM>
	)
  	{
		jjtThis.setName(getToken(0).image);
	}
}


// Conditions are the same as expressions.
void
Condition() :
{}
{
	Expression()
}


/*
 * Expression syntax follows.
 */

void Expression() #Expression :
{}
{
	ImpExpression()
}

void ImpExpression() :
{}
{
	EqvExpression()
	(
		( <IMP> { jjtThis.op = getToken(0).image; } EqvExpression() ) #BinOp(2)
	)*
}

void EqvExpression() :
{}
{
	XorExpression()
	(
		( <EQV> { jjtThis.op = getToken(0).image; } XorExpression() ) #BinOp(2)
	)*
}

void XorExpression() :
{}
{
	OrExpression()
	(
		( <XOR> { jjtThis.op = getToken(0).image; } OrExpression() ) # BinOp(2)
	)*
}

void OrExpression() :
{}
{
	AndExpression()
	(
		( <OR> { jjtThis.op = getToken(0).image; } AndExpression() ) #BinOp(2)
	)*
}

void AndExpression() :
{}
{
	EqualityExpression()
	(
		( <AND> { jjtThis.op = getToken(0).image; } EqualityExpression() ) # BinOp(2)
	)*
}


void EqualityExpression() :
{}
{
	StringConcatExpression()
	(
		LOOKAHEAD(2) ( (  "=" | "<" | ">" | "<=" | ">=" | "<>" | <IS> | <LIKE> )
			{ jjtThis.op = getToken(0).image; } StringConcatExpression() ) #BinOp(2)
	)*
}

void StringConcatExpression() :
{}
{
	AdditiveExpression()
	(
		( "&" { jjtThis.op = getToken(0).image; } AdditiveExpression() ) #BinOp(2)
	)*
}


void AdditiveExpression() :
{}
{
	MultiplicativeExpression()
	(
		( ( "+" | "-" ) { jjtThis.op = getToken(0).image; } MultiplicativeExpression() ) #BinOp(2)
	)*
}

void MultiplicativeExpression() :
{}
{
	ExpoExpression()
	( LOOKAHEAD(1)		// Tell JavaCC that we are aware of the ambiguity generated by the unary ops.
		(( "*" | "/" | "\\" | <MOD> ) { jjtThis.op = getToken(0).image; } ExpoExpression() ) #BinOp(2)
	) *
}

void ExpoExpression() :
{}
{
	DotOpExpression()
	( LOOKAHEAD(1)
		( ( "^" ) { jjtThis.op = getToken(0).image; } DotOpExpression() ) #BinOp(2)
	)*
}


void DotOpExpression() :
{}
{
	UnaryOps()
	( LOOKAHEAD(1)
	  (
		  "." { jjtThis.op = getToken(0).image; } DotOperand()
		| "!" { jjtThis.op = getToken(0).image; } BangOperand()
	  ) #BinOp(2)
	 )*
}

/**
**  NB: The argument following a "!" can be ANYTHING -- !X is treated as
**  .Item("X")
*/
JAVACODE
void BangOperand() #Name
{
	if (getToken(1).image.equals("["))
	{
		while (!getToken(0).image.equals("]"))
			getNextToken();
	}
	else if (getToken(1).kind != EOL)
	{
		getAnyToken();
	}
	else
		throw new ParseException("Expected operand after \"!\"");
}

void DotOperand() :
{}
{
	AnyName() ( "(" ArgList() ")" )?
}

void UnaryOps() :
{}
{
	/*
	** Unary + and - have the same precedence as "*" etc, so that
	** "- x ^ y" is interpreted as "- (x^y)".
	*/

	/*
	** Note that a hash sign is permitted before an ExpTerminal to cater for the VB
	** file IO constructs that expect hash signs, e.g.
	** x = Input(1, #fileno)
	*/

	(
		( "."    		{ jjtThis.op = getToken(0).image; } ExpTerminal()				) #UnaryOp(1)
	  | ( "!"    		{ jjtThis.op = getToken(0).image; } BangOperand()				) #UnaryOp(1)
	  | LOOKAHEAD(1) ( <NEW>  		{ jjtThis.op = getToken(0).image; } UnaryOps()					) #UnaryOp(1)
	  | ( "+"    		{ jjtThis.op = getToken(0).image; } MultiplicativeExpression()	) #UnaryOp(1)
	  | ( "-"    		{ jjtThis.op = getToken(0).image; } MultiplicativeExpression()	) #UnaryOp(1)
	  | ( <NOT>  		{ jjtThis.op = getToken(0).image; } UnaryOps()					) #UnaryOp(1)
	  | LOOKAHEAD(1) ( <TYPEOF>		{ jjtThis.op = getToken(0).image; } UnaryOps()					) #UnaryOp(1)
	  | ( <ADDRESSOF>	{ jjtThis.op = getToken(0).image; } UnaryOps()					) #UnaryOp(1)
	  | [ "#" ] ExpTerminal()
	)
}


void ExpTerminal() :
{}
{
	  Literal()
	| "(" Expression() ")"
	| LOOKAHEAD(2) FuncCall()
	| LOOKAHEAD(1) AnyName()
// Can't get the following to work! Screws up nested LA??
//	| LOOKAHEAD(9, AnyName(), {isSpecialMethod(getToken(1).image)}) SpecialFuncCall()
}

void FuncCall() :
{}
{
	// TODO - Need to cope with special methods such as Line, Input(1, #1)

	AnyName()
	(
		( "(" { jjtThis.op = "()"; } ArgList() ")" ) #BinOp(2)
	)+
}

void SpecialFuncCall() :
{}
{
	// TODO
	{System.out.println("SpecialFuncCall");}
	skipToEoln()
}

/**
**	A primary expression is formed from Expression Terminals (literals,
**	function calls, variable names and parenthesized sub-expressions), all
**	potentially linked together by the binary "." and "!" operators.
**	E.g.
**		Obj.SubObj.Method1
**	or
**		Obj.Func("Param1", 4 + 5).Value
**	or plain
**	MethodName
*/
void PrimaryExpression() #PrimaryExpression :
{}
{
	  ( "." | "!" ) PrimaryName() PrimarySuffix()
	| Name() PrimarySuffix()
}

void PrimarySuffix() :
{}
{
	( LOOKAHEAD( ( "." | "!" | "(" ), { !hasLeadingSpace() } )
		(
			( "." | "!" ) PrimaryName()
		  	| "(" ArgList() ")"
		)
	) *
}

void PrimaryName() :
{}
{
	  AnyName()
	| BangOperand()		// TODO: Allows "rs.[a b]"
}



void Literal() #Literal :
{}
{
  <INTEGER_LITERAL>
|
  <LONG_LITERAL>
|
  <FLOATING_POINT_LITERAL>
|
  <STRING_LITERAL>
|
  <DATE_LITERAL>

|
  "true"
|
  "false"
}


void Arguments() #Arguments :
{}
{
  "(" [ ArgumentList() ] ")"
}

void ArgumentList() :
{}
{
  Expression() ( "," Expression() )*
}


// ==============================================================================================================================
/**
**	The following are "oddities" in the VB language -- the "Put #" statement etc
*/

// Semantically
//void LineInputStatement() #Statement :
//{}
//{
//	<LINE> <INPUT> [ "#" ] Expression() "," AnyName()
//}

void GetStatement() #Statement :
{}
{
	<GET> Expression() "," [ Expression() ]  [ "," Expression() ]
}

void PutStatement() #Statement :
{}
{
	<PUT> Expression() "," [ Expression() ]  [ "," Expression() ]
}

void NameStatement() #Statement :
{}
{
	<NAME> Expression() <AS> Expression()
}

void OpenStatement() #Statement :
{}
{
	// Open pathname For mode [Access access] [lock] As [#]filenumber [Len=reclength]

	<OPEN> Expression() <FOR> ( <APPEND> | <BINARY> | <OUTPUT> | <RANDOM> | <IDENTIFIER> )
		[ <ACCESS> ( <READ> [ <WRITE> ] | <WRITE>  ) ]
		[ LockClause() ]
		<AS> Expression()
		[ LOOKAHEAD({isIdentifier("Len")}) <IDENTIFIER> "=" Expression() ]
}

void LockClause() :
{}
{
	  <SHARED>
	| <LOCK> ( <READ> [ <WRITE> ] | <WRITE> )
}

void CloseStatement() #Statement :
{}
{
	<IDENTIFIER> [ FileNumberList() ]
}

void FileNumberList() :
{}
{
	Expression() ( "," Expression() )*
}

// PRINT now handled semantically
//void PrintFileStatement() #Statement :
//{}
//{
//	<PRINT> "#" Expression() PrintList()
//}

void PrintList() :
{}
{
	( ( "," | ";" ) PrintArg() )*
}

void PrintArg() :
{}
{
	[   LOOKAHEAD({ isIdentifier("Spc") }) <IDENTIFIER> "(" Expression() ")"
	  | LOOKAHEAD({ isIdentifier("Tab") }) <IDENTIFIER> [ "(" Expression() ")" ]
	  |	Expression()
	]
}

// ==============================================================================================================================



/**
** Consume at least one End-of-line character.
** NB: A java code loop is used here, as a convenient way to prevent
** ambiguities involving end-of-line in other
** statements.
*/
void Eol() :
{}
{
	<EOL>
	{
		while (getToken(1).kind == EOL)
		{
			getNextToken();
		}
	}
}

void Eos() :
{}
{
	Eol() | ":"
}


JAVACODE
void skipToEoln()
{
	while (getToken(1).kind != EOL && getToken(1).kind != COLON)
	{
		getNextToken();
	}
}

JAVACODE
void Identifier(String id)
{
	  if (!getToken(1).image.equalsIgnoreCase(id))
	  	throw generateParseException();

	  getNextToken();
}

JAVACODE
void error_skipto(int kind) {
  Token t;
  do {
    t = getNextToken();
  } while (t.kind != kind);
    // The above loop consumes tokens all the way upto a token of
    // "kind".  We use a do-while loop rather than a while because the
    // current token is the one immediately before the erroneous token
    // (in our case the token immediately before what should have been
}


// As above, but do not consume the specified token.
JAVACODE
void error_skiptobefore(int kind) {
  while (getToken(1).kind != kind)
  	getNextToken();
}

// Test procedure for PrimaryExprStatement
void TestPrimaryExprStatement() :
{}
{
	Statements() <EOF>
		{
			((VBNode)jjtree.peekNode()).dump(">");
		}
}

JAVACODE
void SkipSpecialFunction()
{

}