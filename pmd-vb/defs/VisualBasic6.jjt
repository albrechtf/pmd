options {
  JAVA_UNICODE_ESCAPE = true;
  CACHE_TOKENS = true;
  STATIC = false;
  // USER_CHAR_STREAM = true;
  JDK_VERSION = "1.5";

  MULTI = true;
  VISITOR = true;
  NODE_USES_PARSER = true;
  // NODE_PACKAGE="net.sourceforge.pmd.lang.vb.ast";

  //DEBUG_PARSER = true;
  //DEBUG_LOOKAHEAD = true;
}


PARSER_BEGIN(VisualBasicParser)
import java.io.*;

public class VisualBasicParser {

public static void main(String args[]) throws Exception {
FileInputStream in = new FileInputStream("D:\\git\\pmd\\pmd-vb\\src\\test\\resources\\jjtest.bas");
VisualBasicParser parser = new VisualBasicParser(in);
parser.Module();
}

}

PARSER_END(VisualBasicParser)


/* keywords */
TOKEN :
{
<ACCESS: <A> <C> <C> <E> <S> <S> >
|< ADDRESSOF: <A> <D> <D> <R> <E> <S> <S> <O> <F> >
|< ALIAS: <A> <L> <I> <A> <S> >
|< AND: <A> <N> <D> >
|< ATTRIBUTE: <A> <T> <T> <R> <I> <B> <U> <T> <E> >
|< APPACTIVATE: <A> <P> <P> <A> <C> <T> <I> <V> <A> <T> <E> >
|< APPEND: <A> <P> <P> <E> <N> <D> >
|< AS: <A> <S> >
|< BEGIN: <B> <E> <G> <I> <N> >
|< BEEP: <B> <E> <E> <P> >
|< BINARY: <B> <I> <N> <A> <R> <Y> >
|< BOOLEAN: <B> <O> <O> <L> <E> <A> <N> >
|< BYVAL: <B> <Y> <V> <A> <L> >
|< BYREF: <B> <Y> <R> <E> <F> >
|< BYTE: <B> <Y> <T> <E> >
|< CALL: <C> <A> <L> <L> >
|< CASE: <C> <A> <S> <E> >
|< CHDIR: <C> <H> <D> <I> <R> >
|< CHDRIVE: <C> <H> <D> <R> <I> <V> <E> >
|< CLASS: <C> <L> <A> <S> <S> >
|< CLOSE: <C> <L> <O> <S> <E> >
|< COLLECTION: <C> <O> <L> <L> <E> <C> <T> <I> <O> <N> >
|< CONST: <C> <O> <N> <S> <T> >
|< DATE: <D> <A> <T> <E> >
|< DECLARE: <D> <E> <C> <L> <A> <R> <E> >
|< DEFBOOL: <D> <E> <F> <B> <O> <O> <L> >
|< DEFBYTE: <D> <E> <F> <B> <Y> <T> <E> >
|< DEFDATE: <D> <E> <F> <D> <A> <T> <E> >
|< DEFDBL: <D> <E> <F> <D> <B> <L> >
|< DEFDEC: <D> <E> <F> <D> <E> <C> >
|< DEFCUR: <D> <E> <F> <C> <U> <R> >
|< DEFINT: <D> <E> <F> <I> <N> <T> >
|< DEFLNG: <D> <E> <F> <L> <N> <G> >
|< DEFOBJ: <D> <E> <F> <O> <B> <J> >
|< DEFSNG: <D> <E> <F> <S> <N> <G> >
|< DEFSTR: <D> <E> <F> <S> <T> <R> >
|< DEFVAR: <D> <E> <F> <V> <A> <R> >
|< DELETESETTING: <D> <E> <L> <E> <T> <E> <S> <E> <T> <T> <I> <N> <G> >
|< DIM: <D> <I> <M> >
|< DO: <D> <O> >
|< DOUBLE: <D> <O> <U> <B> <L> <E> >
|< EACH: <E> <A> <C> <H> >
|< ELSE: <E> <L> <S> <E> >
|< ELSEIF: <E> <L> <S> <E> <I> <F> >
|< END_ENUM: <E> <N> <D> " " <E> <N> <U> <M> >
|< END_FUNCTION: <E> <N> <D> " " <F> <U> <N> <C> <T> <I> <O> <N> >
|< END_IF: <E> <N> <D> " " <I> <F> >
|< END_PROPERTY: <E> <N> <D> " " <P> <R> <O> <P> <E> <R> <T> <Y> >
|< END_SELECT: <E> <N> <D> " " <S> <E> <L> <E> <C> <T> >
|< END_SUB: <E> <N> <D> " " <S> <U> <B> >
|< END_TYPE: <E> <N> <D> " " <T> <Y> <P> <E> >
|< END_WITH: <E> <N> <D> " " <W> <I> <T> <H> >
|< END: <E> <N> <D> >
|< ENUM: <E> <N> <U> <M> >
|< EQV: <E> <Q> <V> >
|< ERASE: <E> <R> <A> <S> <E> >
|< ERROR: <E> <R> <R> <O> <R> >
|< EVENT: <E> <V> <E> <N> <T> >
|< EXIT_DO: <E> <X> <I> <T> " " <D> <O> >
|< EXIT_FOR: <E> <X> <I> <T> " " <F> <O> <R> >
|< EXIT_FUNCTION: <E> <X> <I> <T> " " <F> <U> <N> <C> <T> <I> <O> <N> >
|< EXIT_PROPERTY: <E> <X> <I> <T> " " <P> <R> <O> <P> <E> <R> <T> <Y> >
|< EXIT_SUB: <E> <X> <I> <T> " " <S> <U> <B> >
|< FALSE: <F> <A> <L> <S> <E> >
|< FILECOPY: <F> <I> <L> <E> <C> <O> <P> <Y> >
|< FRIEND: <F> <R> <I> <E> <N> <D> >
|< FOR: <F> <O> <R> >
|< FUNCTION: <F> <U> <N> <C> <T> <I> <O> <N> >
|< GET: <G> <E> <T> >
|< GLOBAL: <G> <L> <O> <B> <A> <L> >
|< GOSUB: <G> <O> <S> <U> <B> >
|< GOTO: <G> <O> <T> <O> >
|< IF: <I> <F> >
|< IMP: <I> <M> <P> >
|< IMPLEMENTS: <I> <M> <P> <L> <E> <M> <E> <N> <T> <S> >
|< IN: <I> <N> >
|< INPUT: <I> <N> <P> <U> <T> >
|< IS: <I> <S> >
|< INTEGER: <I> <N> <T> <E> <G> <E> <R> >
|< KILL: <K> <I> <L> <L> >
|< LOAD: <L> <O> <A> <D> >
|< LOCK: <L> <O> <C> <K> >
|< LONG: <L> <O> <N> <G> >
|< LOOP: <L> <O> <O> <P> >
|< LEN: <L> <E> <N> >
|< LET: <L> <E> <T> >
|< LIB: <L> <I> <B> >
|< LIKE: <L> <I> <K> <E> >
|< LINE_INPUT: <L> <I> <N> <E> " " <I> <N> <P> <U> <T> >
|< LOCK_READ: <L> <O> <C> <K> " " <R> <E> <A> <D> >
|< LOCK_WRITE: <L> <O> <C> <K> " " <W> <R> <I> <T> <E> >
|< LOCK_READ_WRITE: <L> <O> <C> <K> " " <R> <E> <A> <D> " " <W> <R> <I> <T> <E> >
|< LSET: <L> <S> <E> <T> >
|< MACRO_IF:  "#" <I> <F> >
|< MACRO_ELSEIF:  "#" <E> <L> <S> <E> <I> <F> >
|< MACRO_ELSE:  "#" <E> <L> <S> <E> >
|< MACRO_END_IF:  "#" <E> <N> <D> " " <I> <F> >
|< ME: <M> <E> >
|< MID: <M> <I> <D> >
|< MKDIR: <M> <K> <D> <I> <R> >
|< MOD: <M> <O> <D> >
|< NAME: <N> <A> <M> <E> >
|< NEXT: <N> <E> <X> <T> >
|< NEW: <N> <E> <W> >
|< NOT: <N> <O> <T> >
|< NOTHING: <N> <O> <T> <H> <I> <N> <G> >
|< NULL: <N> <U> <L> <L> >
|< ON: <O> <N> >
|< ON_ERROR: <O> <N> " " <E> <R> <R> <O> <R> >
|< OPEN: <O> <P> <E> <N> >
|< OPTIONAL: <O> <P> <T> <I> <O> <N> <A> <L> >
|< OPTION_BASE: <O> <P> <T> <I> <O> <N> " " <B> <A> <S> <E> >
|< OPTION_EXPLICIT: <O> <P> <T> <I> <O> <N> " " <E> <X> <P> <L> <I> <C> <I> <T> >
|< OPTION_COMPARE: <O> <P> <T> <I> <O> <N> " " <C> <O> <M> <P> <A> <R> <E> >
|< OPTION_PRIVATE_MODULE: <O> <P> <T> <I> <O> <N> " " <P> <R> <I> <V> <A> <T> <E> " " <M> <O> <D> <U> <L> <E> >
|< OR: <O> <R> >
|< OUTPUT: <O> <U> <T> <P> <U> <T> >
|< PARAMARRAY: <P> <A> <R> <A> <M> <A> <R> <R> <A> <Y> >
|< PRESERVE: <P> <R> <E> <S> <E> <R> <V> <E> >
|< PRINT: <P> <R> <I> <N> <T> >
|< PRIVATE: <P> <R> <I> <V> <A> <T> <E> >
|< PROPERTY_GET: <P> <R> <O> <P> <E> <R> <T> <Y> " " <G> <E> <T> >
|< PROPERTY_LET: <P> <R> <O> <P> <E> <R> <T> <Y> " " <L> <E> <T> >
|< PROPERTY_SET: <P> <R> <O> <P> <E> <R> <T> <Y> " " <S> <E> <T> >
|< PUBLIC: <P> <U> <B> <L> <I> <C> >
|< PUT: <P> <U> <T> >
|< RANDOM: <R> <A> <N> <D> <O> <M> >
|< RANDOMIZE: <R> <A> <N> <D> <O> <M> <I> <Z> <E> >
|< RAISEEVENT: <R> <A> <I> <S> <E> <E> <V> <E> <N> <T> >
|< READ: <R> <E> <A> <D> >
|< READ_WRITE: <R> <E> <A> <D> " " <W> <R> <I> <T> <E> >
|< REDIM: <R> <E> <D> <I> <M> >
|< REM: <R> <E> <M> >
|< RESET: <R> <E> <S> <E> <T> >
|< RESUME: <R> <E> <S> <U> <M> <E> >
|< RETURN: <R> <E> <T> <U> <R> <N> >
|< RMDIR: <R> <M> <D> <I> <R> >
|< RSET: <R> <S> <E> <T> >
|< SAVEPICTURE: <S> <A> <V> <E> <P> <I> <C> <T> <U> <R> <E> >
|< SAVESETTING: <S> <A> <V> <E> <S> <E> <T> <T> <I> <N> <G> >
|< SEEK: <S> <E> <E> <K> >
|< SELECT: <S> <E> <L> <E> <C> <T> >
|< SENDKEYS: <S> <E> <N> <D> <K> <E> <Y> <S> >
|< SET: <S> <E> <T> >
|< SETATTR: <S> <E> <T> <A> <T> <T> <R> >
|< SHARED: <S> <H> <A> <R> <E> <D> >
|< SINGLE: <S> <I> <N> <G> <L> <E> >
|< SPC: <S> <P> <C> >
|< STATIC: <S> <T> <A> <T> <I> <C> >
|< STEP: <S> <T> <E> <P> >
|< STOP: <S> <T> <O> <P> >
|< STRING: <S> <T> <R> <I> <N> <G> >
|< SUB: <S> <U> <B> >
|< TAB: <T> <A> <B> >
|< TEXT: <T> <E> <X> <T> >
|< THEN: <T> <H> <E> <N> >
|< TIME: <T> <I> <M> <E> >
|< TO: <T> <O> >
|< TRUE: <T> <R> <U> <E> >
|< TYPE: <T> <Y> <P> <E> >
|< TYPEOF: <T> <Y> <P> <E> <O> <F> >
|< UNLOAD: <U> <N> <L> <O> <A> <D> >
|< UNLOCK: <U> <N> <L> <O> <C> <K> >
|< UNTIL: <U> <N> <T> <I> <L> >
|< VARIANT: <V> <A> <R> <I> <A> <N> <T> >
|< VERSION: <V> <E> <R> <S> <I> <O> <N> >
|< WEND: <W> <E> <N> <D> >
|< WHILE: <W> <H> <I> <L> <E> >
|< WIDTH: <W> <I> <D> <T> <H> >
|< WITH: <W> <I> <T> <H> >
|< WITHEVENTS: <W> <I> <T> <H> <E> <V> <E> <N> <T> <S> >
|< WRITE: <W> <R> <I> <T> <E> >
|< XOR: <X> <O> <R> >
}

/* case insensitive chars */
TOKEN :
{
< A: ["a", "A"] >
|< B: ["b", "B"] >
|< C: ["c", "C"] >
|< D: ["d", "D"] >
|< E: ["e", "E"] >
|< F: ["f", "F"] >
|< G: ["g", "G"] >
|< H: ["h", "H"] >
|< I: ["i", "I"] >
|< J: ["j", "J"] >
|< K: ["k", "K"] >
|< L: ["l", "L"] >
|< M: ["m", "M"] >
|< N: ["n", "N"] >
|< O: ["o", "O"] >
|< P: ["p", "P"] >
|< Q: ["q", "Q"] >
|< R: ["r", "R"] >
|< S: ["s", "S"] >
|< T: ["t", "T"] >
|< U: ["u", "U"] >
|< V: ["v", "V"] >
|< W: ["w", "W"] >
|< X: ["x", "X"] >
|< Y: ["y", "Y"] >
|< Z: ["z", "Z"] >
}

/* symbols */
TOKEN:
{
<AMPERSAND : "&">
|<ASSIGN : ":=">
|<DIV : ["\\", "/"]>
|<EQ : "=">
|<GEQ : ">=">
|<GT : ">">
|<LEQ : "<=">
|<LPAREN : "(">
|<LT : "<">
|<MINUS : "-">
|<MINUS_EQ : "-=">
|<MULT : "*">
|<NEQ : "<>">
|<PLUS : "+">
|<PLUS_EQ : "+=">
|<POW : "^">
|<RPAREN : ")">
|<L_SQUARE_BRACKET : "[">
|<R_SQUARE_BRACKET : "]">
}

/* basics */
SPECIAL_TOKEN:
{
<LETTER : ["a"-"z", "A"-"Z", "_"]>
|<LETTERORDIGIT : ["a"-"z", "A"-"Z", "0"-"9", "_"]>
}

/* literals */
TOKEN:
{
<STRINGLITERAL : "\"" (~["\"", "\r", "\n"] | "\"\"")* "\"">
|<DATELITERAL : "#" (~["#", "\r", "\n"])* "#">
|<COLORLITERAL : "&H" (["0"-"9", "A"-"F"])+ ("&")?>
|<INTEGERLITERAL : (<PLUS>|<MINUS>)? (["0"-"9"])+ ( ("e" | "E") (<PLUS>|<MINUS>)? (["0"-"9"]))* ("#" | "&")?>
|<DOUBLELITERAL : (<PLUS>|<MINUS>)? (["0"-"9"])* "." (["0"-"9"])+ ( ("e" | "E") (<PLUS>|<MINUS>)? (["0"-"9"])+)* ("#" | "&")?>
|<FILENUMBER : "#" (<LETTERORDIGIT>)+>
}



/* identifier */
TOKEN:
{
<IDENTIFIER : <LETTER> (<LETTERORDIGIT>)*>
}

/* whitespace, line breaks, comments... */

TOKEN:
{
<WS : ([" ", "\t"])+>
}

TOKEN:
{
<NEWLINE : (<WS>)? (("\r")? "\n" | ": ") (<WS>)?>
}

SKIP:
{
<LINE_CONTINUATION : " _" ("\r")? "\n">
}

// TODO handle comments correctly (store them and check for suppress marker)
SKIP:
{
<COMMENT : (<WS>)? ("\'" | (":")? <REM> " ") (<LINE_CONTINUATION> | ~["\n", "\r"])*>
}

TOKEN:
{
<OPT_NEWLINE : (<NEWLINE>)* (<WS>)?>
}


/***************************************************
 * THE VISUAL BASIC 6 LANGUAGE GRAMMAR STARTS HERE *
 ***************************************************/
ASTModule Module() :
{}
{

<OPT_NEWLINE>
(ModuleHeader() (<NEWLINE>)+)?
(ModuleConfig())? (<NEWLINE>)*
(ModuleAttributes())? (<NEWLINE>)*
(ModuleOptions())? (<NEWLINE>)*
(ModuleBody())? (<NEWLINE>)*
(<WS>)?
<EOF>
{
return jjtThis;
}
}

void ModuleHeader() :
{}
{
 <VERSION> <WS> <DOUBLELITERAL> <WS> <CLASS>
}

void ModuleConfig() :
{}
{
	<BEGIN> (<NEWLINE>)+ 
	(AmbiguousIdentifier() (<WS>)? <EQ> (<WS>)? Literal() <NEWLINE>)+ 
	<END> (<NEWLINE>)+
}

void ModuleAttributes() :
{}
{
 (AttributeStmt() (<NEWLINE>)+)+
}


void ModuleOptions() : 
{}
{
 (ModuleOption() (<NEWLINE>)+)+
}

void ModuleOption() : 
{}
{
	<OPTION_BASE> <WS> <INTEGERLITERAL> // optionBaseStmt
	| <OPTION_COMPARE> <WS> (<BINARY> | <TEXT>) // optionCompareStmt
	| <OPTION_EXPLICIT> // optionExplicitStmt
	| <OPTION_PRIVATE_MODULE> // optionPrivateModuleStmt
}

void ModuleBody() : 
{}
{
	ModuleBodyElement() ((<NEWLINE>)+ ModuleBodyElement())*
}

void ModuleBodyElement() :
{}
{ 
	(
	  SubStmt()
	| FunctionStmt()
	| DeclareStmt()
	| EnumerationStmt() 
	| EventStmt()
	| MacroIfThenElseStmt()
	| PropertyGetStmt() 
	| PropertySetStmt() 
	| PropertyLetStmt() 
	| TypeStmt()
	| ModuleBlock()
	)
}

void ModuleBlock() :
{}
{
	Block()
}

void AttributeStmt() :
{}
{
	<ATTRIBUTE> <WS> ImplicitCallStmt_InStmt() (<WS>)? <EQ> (<WS>)? Literal() ((<WS>)? "," (<WS>)? Literal())*
}

void Block() :
{}
{
	BlockStmt() ((<NEWLINE>)+ (<WS>)? BlockStmt())*
}

void BlockStmt() :
{}
{
	(
	AppactivateStmt()
	| AttributeStmt()
	| BeepStmt()
	| ChdirStmt()
	| ChdriveStmt()
	| CloseStmt()
	| ConstStmt()
	| DateStmt()
	| DeleteSettingStmt()
	| DeftypeStmt()
	| DoLoopStmt()
	| EndStmt()
	| EraseStmt()
	| ErrorStmt()
	| ExitStmt()
	| ExplicitCallStmt()
	| FilecopyStmt()
	| ForEachStmt()
	| ForNextStmt()
	| GetStmt()
	| GoSubStmt()
	| GoToStmt()
	| IfThenElseStmt()
	| ImplementsStmt()
	| InputStmt()
	| KillStmt()
	| LetStmt()
	| LineInputStmt()
	| LineLabel()
	| LoadStmt()
	| LockStmt()
	| LsetStmt()
	| MacroIfThenElseStmt()
	| MidStmt()
	| MkdirStmt()
	| NameStmt()
	| OnErrorStmt()
	| OnGoToStmt()
	| OnGoSubStmt()
	| OpenStmt()
	| PrintStmt()
	| PutStmt()
	| RaiseEventStmt()
	| RandomizeStmt()
	| RedimStmt()
	| ResetStmt()
	| ResumeStmt()
	| ReturnStmt()
	| RmdirStmt()
	| RsetStmt()
	| SavepictureStmt()
	| SaveSettingStmt()
	| SeekStmt()
	| SelectCaseStmt()
	| SendkeysStmt()
	| SetattrStmt()
	| SetStmt()
	| StopStmt()
	| TimeStmt()
	| UnloadStmt()
	| UnlockStmt()
	| VariableStmt()
	| WhileWendStmt()
	| WidthStmt()
	| WithStmt()
	| WriteStmt()
	| ImplicitCallStmt_InBlock()
	)
}

/* Statements */

void AppactivateStmt() : 
{}
{
<APPACTIVATE> <WS> ValueStmt() ((<WS>)? "," (<WS>)? ValueStmt())?
}

void BeepStmt() : 
{}
{
<BEEP>
}

void ChdirStmt() : 
{}
{
<CHDIR> <WS> ValueStmt()
}

void ChdriveStmt() :
{}
{
<CHDRIVE> <WS> ValueStmt()
}

void CloseStmt() : 
{}
{
<CLOSE> (<WS> ValueStmt() ((<WS>)? "," (<WS>)? ValueStmt())*)?
}

void ConstStmt() :
{}
{
 (Visibility() <WS>)? <CONST> <WS> ConstSubStmt() ((<WS>)? "," (<WS>)? ConstSubStmt())*
}

void ConstSubStmt() : 
{}
{
AmbiguousIdentifier() (TypeHint())? (<WS> AsTypeClause())? (<WS>)? <EQ> (<WS>)? ValueStmt()
}

void DateStmt() : 
{}
{
<DATE> (<WS>)? <EQ> (<WS>)? ValueStmt()
}

void DeclareStmt() : 
{}
{
(Visibility() <WS>)? <DECLARE> <WS> (<FUNCTION> | <SUB>) <WS> AmbiguousIdentifier() <WS> <LIB> <WS> <STRINGLITERAL> (<WS> <ALIAS> <WS> <STRINGLITERAL>)? ((<WS>)? ArgList())? (<WS> AsTypeClause())?
}

void DeftypeStmt() :
{}
{ 
	(
		<DEFBOOL> | <DEFBYTE> | <DEFINT> | <DEFLNG> | <DEFCUR> | 
		<DEFSNG> | <DEFDBL> | <DEFDEC> | <DEFDATE> | 
		<DEFSTR> | <DEFOBJ> | <DEFVAR>
	) <WS>
	Letterrange() ((<WS>)? "," (<WS>)? Letterrange())*
}

void DeleteSettingStmt() :
{}
{
<DELETESETTING> <WS> ValueStmt() (<WS>)? "," (<WS>)? ValueStmt() ((<WS>)? "," (<WS>)? ValueStmt())?
}

void DoLoopStmt() :
{}
{
	(
	<DO> (<NEWLINE>)+ 
	(Block() (<NEWLINE>)+)? 
	<LOOP>
	|
	<DO> <WS> (<WHILE> | <UNTIL>) <WS> ValueStmt() (<NEWLINE>)+ 
	(Block() (<NEWLINE>)+)? 
	<LOOP>
	| 
	<DO> (<NEWLINE>)+ 
	(Block() (<NEWLINE>)+) 
	<LOOP> <WS> (<WHILE> | <UNTIL>) <WS> ValueStmt()
	)
}


void EndStmt() : 
{}
{
<END>
}

void EnumerationStmt() :
{}
{ 
	(Visibility() <WS>)? <ENUM> <WS> AmbiguousIdentifier() (<NEWLINE>)+ 
	(EnumerationStmt_Constant())* 
	<END_ENUM>
}

void EnumerationStmt_Constant() : 
{}
{
AmbiguousIdentifier() ((<WS>)? <EQ> (<WS>)? ValueStmt())? (<NEWLINE>)+
}

void EraseStmt() :
{}
{
<ERASE> <WS> ValueStmt()
}

void ErrorStmt() :
{}
{
<ERROR> <WS> ValueStmt()
}

void EventStmt() :
{}
{
(Visibility() <WS>)? <EVENT> <WS> AmbiguousIdentifier() (<WS>)? ArgList()
}

void ExitStmt() : 
{}
{
( <EXIT_DO> | <EXIT_FOR> | <EXIT_FUNCTION> | <EXIT_PROPERTY> | <EXIT_SUB> )
}

void FilecopyStmt() : 
{}
{
<FILECOPY> <WS> ValueStmt() (<WS>)? "," (<WS>)? ValueStmt()
}

void ForEachStmt() :
{}
{ 
	<FOR> <WS> <EACH> <WS> AmbiguousIdentifier() (TypeHint())? <WS> <IN> <WS> ValueStmt() (<NEWLINE>)+ 
	(Block() (<NEWLINE>)+)?
	<NEXT> (<WS> AmbiguousIdentifier())?
}

void ForNextStmt() :
{}
{ 
	<FOR> <WS> AmbiguousIdentifier() (TypeHint())? (<WS> AsTypeClause())? (<WS>)? <EQ> (<WS>)? ValueStmt() <WS> <TO> <WS> ValueStmt() (<WS> <STEP> <WS> ValueStmt())? (<NEWLINE>)+ 
	(Block() (<NEWLINE>)+)? 
	<NEXT> (<WS> AmbiguousIdentifier())?
}

void FunctionStmt() :
{}
{
	(Visibility() <WS>)? (<STATIC> <WS>)? <FUNCTION> <WS> AmbiguousIdentifier() ((<WS>)? ArgList())? (<WS> AsTypeClause())? (<NEWLINE>)+
	(Block() (<NEWLINE>)+)?
	<END_FUNCTION>
}

void GetStmt() : 
{}
{
<GET> <WS> ValueStmt() (<WS>)? "," (<WS>)? (ValueStmt())? (<WS>)? "," (<WS>)? ValueStmt()
}

void GoSubStmt() : 
{}
{
<GOSUB> <WS> ValueStmt()
}

void GoToStmt() :
{}
{
<GOTO> <WS> ValueStmt()
}

void IfThenElseStmt() :
{}
{ 
	(
	<IF> <WS> IfConditionStmt() <WS> <THEN> <WS> BlockStmt() (<WS> <ELSE> <WS> BlockStmt())? // inlineIfThenElse
	| IfBlockStmt() (IfElseIfBlockStmt())* (IfElseBlockStmt())? <END_IF> // blockIfThenElse
	)
}

void IfBlockStmt() :
{}
{ 
	<IF> <WS> IfConditionStmt() <WS> <THEN> (<NEWLINE>)+ 
	(Block() (<NEWLINE>)+)?
}

void IfConditionStmt() :
{}
{
	ValueStmt()
}

void IfElseIfBlockStmt() :
{}
{ 
	<ELSEIF> <WS> IfConditionStmt() <WS> <THEN> (<NEWLINE>)+ 
	(Block() (<NEWLINE>)+)?
}

void IfElseBlockStmt() :
{}
{ 
	<ELSE> (<NEWLINE>)+ 
	(Block() (<NEWLINE>)+)?
}

void ImplementsStmt() : 
{}
{
<IMPLEMENTS> <WS> AmbiguousIdentifier()
}

void InputStmt() : 
{}
{
<INPUT> <WS> ValueStmt() ((<WS>)? "," (<WS>)? ValueStmt())+
}

void KillStmt() : 
{}
{
<KILL> <WS> ValueStmt()
}

void LetStmt() :
{}
{
(<LET> <WS>)? ImplicitCallStmt_InStmt() (<WS>)? (<EQ> | <PLUS_EQ> | <MINUS_EQ>) (<WS>)? ValueStmt()
}

void LineInputStmt() : 
{}
{
<LINE_INPUT> <WS> ValueStmt() (<WS>)? "," (<WS>)? ValueStmt()
}

void LoadStmt() :
{}
{
<LOAD> <WS> ValueStmt()
}

void LockStmt() :
{}
{
<LOCK> <WS> ValueStmt() ((<WS>)? "," (<WS>)? ValueStmt() (<WS> <TO> <WS> ValueStmt())?)?
}

void LsetStmt() :
{}
{
<LSET> <WS> ImplicitCallStmt_InStmt() (<WS>)? <EQ> (<WS>)? ValueStmt()
}

void MacroIfThenElseStmt() : 
{}
{
MacroIfBlockStmt() (MacroElseIfBlockStmt())* (MacroElseBlockStmt())? <MACRO_END_IF>
}

void MacroIfBlockStmt() :
{}
{ 
	<MACRO_IF> <WS> IfConditionStmt() <WS> <THEN> (<NEWLINE>)+ 
	(ModuleBody() (<NEWLINE>)+)?
}

void MacroElseIfBlockStmt() :
{}
{ 
	<MACRO_ELSEIF> <WS> IfConditionStmt() <WS> <THEN> (<NEWLINE>)+ 
	(ModuleBody() (<NEWLINE>)+)?
}

void MacroElseBlockStmt() :
{}
{
	<MACRO_ELSE> (<NEWLINE>)+ 
	(ModuleBody() (<NEWLINE>)+)?
}

void MidStmt() : 
{}
{
<MID> (<WS>)? <LPAREN> (<WS>)? ArgsCall() (<WS>)? <RPAREN>
}

void MkdirStmt() :
{}
{
<MKDIR> <WS> ValueStmt()
}

void NameStmt() : 
{}
{
<NAME> <WS> ValueStmt() <WS> <AS> <WS> ValueStmt()
}

void OnErrorStmt() : 
{}
{
<ON_ERROR> <WS> (<GOTO> <WS> ValueStmt() | <RESUME> <WS> <NEXT>)
}

void OnGoToStmt() : 
{}
{
<ON> <WS> ValueStmt() <WS> <GOTO> <WS> ValueStmt() ((<WS>)? "," (<WS>)? ValueStmt())*
}

void OnGoSubStmt() : 
{}
{
<ON> <WS> ValueStmt() <WS> <GOSUB> <WS> ValueStmt() ((<WS>)? "," (<WS>)? ValueStmt())*
}

void OpenStmt() :
{}
{ 
	<OPEN> <WS> ValueStmt() <WS> <FOR> <WS> (<APPEND> | <BINARY> | <INPUT> | <OUTPUT> | <RANDOM>) 
	(<WS> <ACCESS> <WS> (<READ> | <WRITE> | <READ_WRITE>))?
	(<WS> (<SHARED> | <LOCK_READ> | <LOCK_WRITE> | <LOCK_READ_WRITE>))?
	<WS> <AS> <WS> ValueStmt()
	(<WS> <LEN> (<WS>)? <EQ> (<WS>)? ValueStmt())?
}

void OutputList() :
{}
{
	(
	OutputList_Expression() ((<WS>)? (";" | ",") (<WS>)? (OutputList_Expression())?)*
	| (OutputList_Expression())? ((<WS>)? (";" | ",") (<WS>)? (OutputList_Expression())?)+
	)
}

void OutputList_Expression() :
{}
{ 
	(
	ValueStmt()
	| (<SPC> | <TAB>) ((<WS>)? <LPAREN> (<WS>)? ArgsCall() (<WS>)? <RPAREN>)?
	)
}


void PrintStmt() :
{}
{
<PRINT> <WS> ValueStmt() (<WS>)? "," ((<WS>)? OutputList())?
}

void PropertyGetStmt() :
{}
{ 
	(Visibility() <WS>)? (<STATIC> <WS>)? <PROPERTY_GET> <WS> AmbiguousIdentifier() ((<WS>)? ArgList())? (<WS> AsTypeClause())? (<NEWLINE>)+ 
	(Block() (<NEWLINE>)+)? 
	<END_PROPERTY>
}

void PropertySetStmt() :
{}
{ 
	(Visibility() <WS>)? (<STATIC> <WS>)? <PROPERTY_SET> <WS> AmbiguousIdentifier() ((<WS>)? ArgList())? (<NEWLINE>)+ 
	(Block() (<NEWLINE>)+)? 
	<END_PROPERTY>
}

void PropertyLetStmt() : 
{}
{
	(Visibility() <WS>)? (<STATIC> <WS>)? <PROPERTY_LET> <WS> AmbiguousIdentifier() ((<WS>)? ArgList())? (<NEWLINE>)+ 
	(Block() (<NEWLINE>)+)? 
	<END_PROPERTY>
}

void PutStmt() : 
{}
{
<PUT> <WS> ValueStmt() (<WS>)? "," (<WS>)? (ValueStmt())? (<WS>)? "," (<WS>)? ValueStmt()
}

void RaiseEventStmt() :
{}
{
<RAISEEVENT> <WS> AmbiguousIdentifier() ((<WS>)? <LPAREN> (<WS>)? (ArgsCall() (<WS>)?)? <RPAREN>)?
}

void RandomizeStmt() : 
{}
{
<RANDOMIZE> (<WS> ValueStmt())?
}

void RedimStmt() : 
{}
{
<REDIM> <WS> (<PRESERVE> <WS>)? RedimSubStmt() ((<WS>)? "," (<WS>)? RedimSubStmt())*
}

void RedimSubStmt() : 
{}
{
ImplicitCallStmt_InStmt() (<WS>)? <LPAREN> (<WS>)? Subscripts() (<WS>)? <RPAREN> (<WS> AsTypeClause())?
}

void ResetStmt() : 
{}
{
<RESET>
}

void ResumeStmt() : 
{}
{
<RESUME> (<WS> (<NEXT> | AmbiguousIdentifier()))?
}

void ReturnStmt() : 
{}
{
<RETURN>
}

void RmdirStmt() : 
{}
{
<RMDIR> <WS> ValueStmt()
}

void RsetStmt() : 
{}
{
<RSET> <WS> ImplicitCallStmt_InStmt() (<WS>)? <EQ> (<WS>)? ValueStmt()
}

void SavepictureStmt() :
{}
{
<SAVEPICTURE> <WS> ValueStmt() (<WS>)? "," (<WS>)? ValueStmt()
}

void SaveSettingStmt() : 
{}
{
<SAVESETTING> <WS> ValueStmt() (<WS>)? "," (<WS>)? ValueStmt() (<WS>)? "," (<WS>)? ValueStmt() (<WS>)? "," (<WS>)? ValueStmt()
}

void SeekStmt() : 
{}
{
<SEEK> <WS> ValueStmt() (<WS>)? "," (<WS>)? ValueStmt()
}

void SelectCaseStmt() :
{}
{ 
	<SELECT> <WS> <CASE> <WS> ValueStmt() (<NEWLINE>)+ 
	(SC_Case())* 
	(SC_CaseElse())?
	(<WS>)? <END_SELECT>
}

void SC_Case() :
{}
{ 
	<CASE> <WS> SC_Cond() (<WS>)? ((":")? (<NEWLINE>)* | (<NEWLINE>)+)  
	(Block() (<NEWLINE>)+)?
}

void SC_Cond() :
{}
{
	( 
	<IS> (<WS>)? ComparisonOperator() (<WS>)? ValueStmt() // caseCondIs
	| ValueStmt() ((<WS>)? "," (<WS>)? ValueStmt())* // caseCondValue
	| <INTEGERLITERAL> <WS> <TO> <WS> ValueStmt() ((<WS>)? "," (<WS>)? ValueStmt())* // caseCondTo
	)
}

void SC_CaseElse() :
{}
{ 
	<CASE> <WS> <ELSE> (<WS>)? ((":")? (<NEWLINE>)* | (<NEWLINE>)+)  
	(Block() (<NEWLINE>)+)?
}

void SendkeysStmt() : 
{}
{
<SENDKEYS> <WS> ValueStmt() ((<WS>)? "," (<WS>)? ValueStmt())?
}

void SetattrStmt() : 
{}
{
<SETATTR> <WS> ValueStmt() (<WS>)? "," (<WS>)? ValueStmt()
}

void SetStmt() : 
{}
{
<SET> <WS> ImplicitCallStmt_InStmt() (<WS>)? <EQ> (<WS>)? ValueStmt()
}

void StopStmt() : 
{}
{
<STOP>
}

void SubStmt() :
{}
{ 
	(Visibility() <WS>)? (<STATIC> <WS>)? <SUB> <WS> AmbiguousIdentifier() ((<WS>)? ArgList())? (<NEWLINE>)+ 
	(Block() (<NEWLINE>)+)? 
	<END_SUB>
}


void TimeStmt() : 
{}
{
<TIME> (<WS>)? <EQ> (<WS>)? ValueStmt()
}

void TypeStmt() : 
{}
{
	(Visibility() <WS>)? <TYPE> <WS> AmbiguousIdentifier() (<NEWLINE>)+ 
	(TypeStmt_Element())*
	<END_TYPE>
}

void TypeStmt_Element() : 
{}
{
AmbiguousIdentifier() ((<WS>)? <LPAREN> ((<WS>)? Subscripts())? (<WS>)? <RPAREN>)? (<WS> AsTypeClause())? (<NEWLINE>)+
}

void TypeOfStmt() : 
{}
{
<TYPEOF> <WS> ValueStmt() (<WS> <IS> <WS> Type())?
}

void UnloadStmt() : 
{}
{
<UNLOAD> <WS> ValueStmt()
}

void UnlockStmt() : 
{}
{
<UNLOCK> <WS> ValueStmt() ((<WS>)? "," (<WS>)? ValueStmt() (<WS> <TO> <WS> ValueStmt())?)?
}

void ValueStmt() :
{}
{ 
	(
	Literal() #LiteralStmt
	| MidStmt()
	| <NEW> <WS> ValueStmt() #NewStmt
	| ImplicitCallStmt_InStmt()
	| TypeOfStmt()
	| <LPAREN> (<WS>)? ValueStmt() ((<WS>)? "," (<WS>)? ValueStmt())* <RPAREN> #StructStmt
	| ImplicitCallStmt_InStmt() (<WS>)? <ASSIGN> (<WS>)? ValueStmt() #AssignStmt
	| <PLUS> (<WS>)? ValueStmt() #PlusStmt
	| <ADDRESSOF> <WS> ValueStmt() #AddressOfStmt
	| <MINUS> (<WS>)? ValueStmt() #NegationStmt
	| <NOT> <WS> ValueStmt() #NotStmt
	)
	
	(ValueStmtOperator() ValueStmt())*
}

void ValueStmtOperator() :
{}
{
	(
	  (<WS>)? <PLUS> (<WS>)?
	| <WS> <AMPERSAND> <WS>
	| <WS> <AND> <WS> 
	| (<WS>)? <LT> (<WS>)? 
	| (<WS>)? <LEQ> (<WS>)? 
	| (<WS>)? <GT> (<WS>)? 
	| (<WS>)? <GEQ> (<WS>)? 
	| (<WS>)? <EQ> (<WS>)? 
	| (<WS>)? <NEQ> (<WS>)? 
	| (<WS>)? <DIV> (<WS>)? 
	| <WS> <EQV> <WS> 
	| <WS> <IMP> <WS> 
	| <WS> <IS> <WS> 
	| <WS> <LIKE> <WS> 
	| (<WS>)? <MINUS> (<WS>)? 
	| (<WS>)? <MOD> (<WS>)? 
	| (<WS>)? <MULT> (<WS>)? 
	| (<WS>)? <OR> (<WS>)? 
	| (<WS>)? <POW> (<WS>)? 
	| (<WS>)? <XOR> (<WS>)? 
	)
}

void VariableStmt() :
{}
{
(<DIM> | <STATIC> | Visibility()) <WS> (<WITHEVENTS> <WS>)? VariableListStmt()
}

void VariableListStmt() : 
{}
{
VariableSubStmt() ((<WS>)? "," (<WS>)? VariableSubStmt())*
}

void VariableSubStmt() : 
{}
{
AmbiguousIdentifier() ((<WS>)? <LPAREN> (<WS>)? (Subscripts() (<WS>)?)? <RPAREN> (<WS>)?)? (TypeHint())? (<WS> AsTypeClause())?
}

void WhileWendStmt() :
{}
{ 
	<WHILE> <WS> ValueStmt() (<NEWLINE>)+ 
	(Block() <NEWLINE>)* 
	<WEND>
}

void WidthStmt() : 
{}
{
<WIDTH> <WS> ValueStmt() (<WS>)? "," (<WS>)? ValueStmt()
}

void WithStmt() :
{}
{ 
	<WITH> <WS> ImplicitCallStmt_InStmt() (<NEWLINE>)+ 
	(Block() (<NEWLINE>)+)? 
	<END_WITH>
}

void WriteStmt() : 
{}
{
<WRITE> <WS> ValueStmt() (<WS>)? "," ((<WS>)? OutputList())?
}


/* complex call statements --------------------------------- */

void ExplicitCallStmt() :
{}
{
	( 
	ECS_ProcedureCall() 
	| ECS_MemberProcedureCall()
	) 
}

void ECS_ProcedureCall() : 
{}
{
<CALL> <WS> AmbiguousIdentifier() (TypeHint())? ((<WS>)? <LPAREN> (<WS>)? (ArgsCall() (<WS>)?)? <RPAREN>)?
}

void ECS_MemberProcedureCall() : 
{}
{
<CALL> <WS> (VariableCallStmt())? (MemberPropertyCallStmt())* "." AmbiguousIdentifier() (TypeHint())? ((<WS>)? <LPAREN> (<WS>)? (ArgsCall() (<WS>)?)? <RPAREN>)?
}

void ImplicitCallStmt_InBlock() :
{}
{
	(
	ICS_B_SubCall()
	| ICS_B_FunctionCall()
	| ICS_B_MemberSubCall()
	| ICS_B_MemberFunctionCall()
	)
}

// certainIdentifier instead of AmbiguousIdentifier() for preventing ambiguity with statement keywords 
void ICS_B_SubCall() : 
{}
{
CertainIdentifier() (<WS> ArgsCall())?
}

void ICS_B_FunctionCall() : 
{}
{
FunctionOrArrayCallStmt() (DictionaryCallStmt())?
}

void ICS_B_MemberSubCall() : 
{}
{
(ImplicitCallStmt_InStmt())* MemberSubCallStmt()
}

void ICS_B_MemberFunctionCall() : 
{}
{
(ImplicitCallStmt_InStmt())* MemberFunctionOrArrayCallStmt() (DictionaryCallStmt())?
}

void ImplicitCallStmt_InStmt() :
{}
{
	(
	ICS_S_VariableCall()
	| ICS_S_FunctionOrArrayCall()
	| ICS_S_DictionaryCall()
	| ICS_S_MembersCall()
	)
}

void ICS_S_VariableCall() : 
{}
{
VariableCallStmt() (DictionaryCallStmt())?
}

void ICS_S_FunctionOrArrayCall() : 
{}
{
FunctionOrArrayCallStmt() (DictionaryCallStmt())?
}

void ICS_S_DictionaryCall() : 
{}
{
DictionaryCallStmt()
}

void ICS_S_MembersCall() : 
{}
{
(VariableCallStmt() | FunctionOrArrayCallStmt())? (MemberCall_Value())+ (DictionaryCallStmt())?
}


// member call statements ----------------------------------

void MemberPropertyCallStmt() : 
{}
{
"." AmbiguousIdentifier()
}

void MemberFunctionOrArrayCallStmt() : 
{}
{
"." FunctionOrArrayCallStmt()
}

void MemberSubCallStmt() : 
{}
{
"." AmbiguousIdentifier() (<WS> ArgsCall())?
}

void MemberCall_Value() : 
{}
{
(MemberPropertyCallStmt() | MemberFunctionOrArrayCallStmt())
}


// atomic call statements ----------------------------------

void VariableCallStmt() : 
{}
{
AmbiguousIdentifier() (TypeHint())?
}

void DictionaryCallStmt() : 
{}
{
"!" AmbiguousIdentifier() (TypeHint())?
}

void FunctionOrArrayCallStmt() : 
{}
{
(AmbiguousIdentifier() | BaseType()) (TypeHint())? (<WS>)? <LPAREN> (<WS>)? (ArgsCall() (<WS>)?)? <RPAREN>
}

void ArgsCall() : 
{}
{
((ArgCall())? (<WS>)? ("," | ";") (<WS>)?)* ArgCall() ((<WS>)? ("," | ";") (<WS>)? (ArgCall())?)*
}

void ArgCall() : 
{}
{
((<BYVAL> | <BYREF> | <PARAMARRAY>) <WS>)? ValueStmt()
}


// atomic rules for statements

void ArgList() : 
{}
{
<LPAREN> ((<WS>)? Arg() ((<WS>)? "," (<WS>)? Arg())*)? (<WS>)? <RPAREN>
}

void Arg() : 
{}
{
(<OPTIONAL> <WS>)? ((<BYVAL> | <BYREF>) <WS>)? (<PARAMARRAY> <WS>)? AmbiguousIdentifier() ((<WS>)? <LPAREN> (<WS>)? <RPAREN>)? (<WS> AsTypeClause())? ((<WS>)? ArgDefaultValue())?
}

void ArgDefaultValue() : 
{}
{
<EQ> (<WS>)? (Literal() | AmbiguousIdentifier())
}

void Subscripts() : 
{}
{
Subscript() ((<WS>)? "," (<WS>)? Subscript())*
}

void Subscript() : 
{}
{
(ValueStmt() <WS> <TO> <WS>)? ValueStmt()
}


// atomic rules ----------------------------------

void AmbiguousIdentifier() :
{}
{
	( 
	(<IDENTIFIER> | AmbiguousKeyword())+
	| <L_SQUARE_BRACKET> (<IDENTIFIER> | AmbiguousKeyword())+ <R_SQUARE_BRACKET>
	)
}

void AsTypeClause() : 
{}
{
<AS> <WS> (<NEW> <WS>)? Type() (<WS> FieldLength())?
}

void BaseType() : 
{}
{
<BOOLEAN> | <BYTE> | <COLLECTION> | <DATE> | <DOUBLE> | <INTEGER> | <LONG> | <SINGLE> | <STRING> | <VARIANT>
}

void CertainIdentifier() :
{}
{
	( 
	<IDENTIFIER> (AmbiguousKeyword() | <IDENTIFIER>)*
	| AmbiguousKeyword() (AmbiguousKeyword() | <IDENTIFIER>)+
	)
}

void ComparisonOperator() : 
{}
{
<LT> | <LEQ> | <GT> | <GEQ> | <EQ> | <NEQ> | <IS> | <LIKE>
}

void ComplexType() : 
{}
{
AmbiguousIdentifier() ("." AmbiguousIdentifier())*
}

void FieldLength() :
{}
{
<MULT> (<WS>)? (<INTEGERLITERAL> | AmbiguousIdentifier())
}

void Letterrange() : 
{}
{
CertainIdentifier() ((<WS>)? <MINUS> (<WS>)? CertainIdentifier())?
}

void LineLabel() : 
{}
{
AmbiguousIdentifier() ":"
}

void Literal() : 
{}
{
( <COLORLITERAL> | <DATELITERAL> | <DOUBLELITERAL> | <FILENUMBER> | <INTEGERLITERAL> | <STRINGLITERAL> | <TRUE> | <FALSE> | <NOTHING> | <NULL> )
}

void Type() : 
{}
{
(BaseType() | ComplexType()) ((<WS>)? <LPAREN> (<WS>)? <RPAREN>)?
}

void TypeHint() : 
{}
{
( "&" | "%" | "#" | "!" | "@" | "$" )
}

void Visibility() : 
{}
{
<PRIVATE> | <PUBLIC> | <FRIEND> | <GLOBAL>
}

// ambiguous keywords
void AmbiguousKeyword() :
{}
{ 
	<ACCESS> | <ADDRESSOF> | <ALIAS> | <AND> | <ATTRIBUTE> | <APPACTIVATE> | <APPEND> | <AS> |
	<BEEP> | <BEGIN> | <BINARY> | <BOOLEAN> | <BYVAL> | <BYREF> | <BYTE> | 
	<CALL> | <CASE> | <CLASS> | <CLOSE> | <CHDIR> | <CHDRIVE> | <COLLECTION> | <CONST> | 
	<DATE> | <DECLARE> | <DEFBOOL> | <DEFBYTE> | <DEFCUR> | <DEFDBL> | <DEFDATE> | <DEFDEC> | <DEFINT> | <DEFLNG> | <DEFOBJ> | <DEFSNG> | <DEFSTR> | <DEFVAR> | <DELETESETTING> | <DIM> | <DO> | <DOUBLE> | 
	<EACH> | <ELSE> | <ELSEIF> | <END> | <ENUM> | <EQV> | <ERASE> | <ERROR> | <EVENT> | 
	<FALSE> | <FILECOPY> | <FRIEND> | <FOR> | <FUNCTION> | 
	<GET> | <GLOBAL> | <GOSUB> | <GOTO> | 
	<IF> | <IMP> | <IMPLEMENTS> | <IN> | <INPUT> | <IS> | <INTEGER> |
	<KILL> | 
	<LOAD> | <LOCK> | <LONG> | <LOOP> | <LEN> | <LET> | <LIB> | <LIKE> | <LSET> |
	<ME> | <MID> | <MKDIR> | <MOD> | 
	<NAME> | <NEXT> | <NEW> | <NOT> | <NOTHING> | <NULL> | 
	<ON> | <OPEN> | <OPTIONAL> | <OR> | <OUTPUT> | 
	<PARAMARRAY> | <PRESERVE> | <PRINT> | <PRIVATE> | <PUBLIC> | <PUT> |
	<RANDOM> | <RANDOMIZE> | <RAISEEVENT> | <READ> | <REDIM> | <REM> | <RESET> | <RESUME> | <RETURN> | <RMDIR> | <RSET> |
	<SAVEPICTURE> | <SAVESETTING> | <SEEK> | <SELECT> | <SENDKEYS> | <SET> | <SETATTR> | <SHARED> | <SINGLE> | <SPC> | <STATIC> | <STEP> | <STOP> | <STRING> | <SUB> | 
	<TAB> | <TEXT> | <THEN> | <TIME> | <TO> | <TRUE> | <TYPE> | <TYPEOF> | 
	<UNLOAD> | <UNLOCK> | <UNTIL> | 
	<VARIANT> | <VERSION> | 
	<WEND> | <WHILE> | <WIDTH> | <WITH> | <WITHEVENTS> | <WRITE> |
	<XOR>
}
